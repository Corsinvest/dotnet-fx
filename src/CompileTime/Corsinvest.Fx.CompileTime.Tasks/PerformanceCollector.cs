using System.Diagnostics;
using System.Text;
using Corsinvest.Fx.CompileTime.Helpers;
using Microsoft.CodeAnalysis;

namespace Corsinvest.Fx.CompileTime.Tasks;

internal class PerformanceCollector
{
    public string FileName { get; }
    private readonly List<Item> _items = [];
    private readonly Stopwatch _overallStopwatch = new();
    private int _totalProcessed;
    private int _successCount;
    private int _errorCount;
    private readonly string _buildConfiguration = "Unknown";

    public PerformanceCollector(string buildConfiguration, string projectDir)
    {
        _overallStopwatch.Start();
        _buildConfiguration = buildConfiguration;
        FileName = Path.Combine(projectDir, "CompileTimeReport.md");
    }

    public void Add(Item data)
    {
        _items.Add(data);
        _totalProcessed++;

        if (string.IsNullOrEmpty(data.ErrorMessage))
        {
            _successCount++;
        }
        else
        {
            _errorCount++;
        }
    }

    public void StopTracking() => _overallStopwatch.Stop();

    public void GenerateReportContent(string persistentCacheFileName)
    {
        var sb = new StringBuilder();

        // Header
        sb.AppendLine("# CompileTime Performance Report");
        sb.AppendLine();
        sb.AppendLine("Generated by [Corsinvest.Fx.CompileTime](https://github.com/Corsinvest/dotnet-fx/tree/master/src/CompileTime)");
        sb.AppendLine();
        sb.AppendLine($"**Total:** {_totalProcessed} methods | {_overallStopwatch.ElapsedMilliseconds:N0}ms total");
        sb.AppendLine();
        sb.AppendLine($"**Generated:** {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        sb.AppendLine();
        sb.AppendLine($"**Cache File:** `{persistentCacheFileName}`");
        sb.AppendLine();
        sb.AppendLine($"**Configuration:** {_buildConfiguration}");
        sb.AppendLine();
        sb.AppendLine($"**Success:** {_successCount}");
        sb.AppendLine();
        sb.AppendLine($"**Error:** {_errorCount}");

        if (_items.Count != 0)
        {
            foreach (var classGroup in _items.Where(a => string.IsNullOrEmpty(a.ErrorMessage))
                                            .GroupBy(a => a.ClassName)
                                            .OrderBy(a => a.Key))
            {
                sb.AppendLine();

                var className = classGroup.Key;

                // Group by base method name to avoid duplicates for parameterized methods
                var methods = classGroup.GroupBy(a => a.MethodName)
                                        .Select(g => g.OrderByDescending(m => m.ExecutionTimeMs).First())
                                        .OrderByDescending(a => a.ExecutionTimeMs);

                if (!methods.Any()) { continue; }

                // Get namespace from first method in class
                var namespaceName = methods.FirstOrDefault()?.Namespace ?? string.Empty;
                var fullClassName = !string.IsNullOrEmpty(namespaceName) && namespaceName != "<global namespace>"
                                        ? $"{namespaceName}.{className}"
                                        : className;

                sb.AppendLine($"## ðŸ“‹ {fullClassName}");
                sb.AppendLine();
                sb.AppendLine($"*Generated class: `{CompileTimeHelper.GenerateSafeClassName(namespaceName, className)}` (in namespace CompileTime)*");
                sb.AppendLine();
                sb.AppendLine("| Status | Method | Time | Cache | Calls | Memory (Size) | Notes |");
                sb.AppendLine("|--------|--------|------|-------|-------|---------------|-------|");

                // Show base methods first
                foreach (var method in methods)
                {
                    // For methods with parameter variations, show base method without time
                    if (!string.IsNullOrEmpty(method.Parameters))
                    {
                        sb.AppendLine($"|  | **{method.MethodName}()** |  |  |  |  |  |");

                        var invocations = classGroup.Where(a => a.Namespace == method.Namespace
                                                                && a.ClassName == className
                                                                && a.MethodName == method.MethodName);

                        // Group by unique parameters to avoid duplicates
                        foreach (var parameters in invocations.Select(a => a.Parameters).Distinct())
                        {
                            var paramInvocation = invocations.First(a => a.Parameters == parameters);
                            var count = invocations.Count(a => a.Parameters == parameters);

                            // Calculate status for this specific parameter invocation
                            var status = paramInvocation.WasSkipped
                                            ? "â­ï¸ SKIP"
                                            : paramInvocation.ThresholdExceeded
                                                ? "âš ï¸ SLOW"
                                                : "âœ… OK";

                            var notes = string.Empty;
                            if (paramInvocation.ThresholdExceeded && !paramInvocation.WasSuppressed)
                            {
                                notes = $"Slow (+{paramInvocation.ExecutionTimeMs - paramInvocation.ThresholdMs}ms over {paramInvocation.ThresholdMs}ms limit)";
                            }
                            else if (paramInvocation.WasSuppressed)
                            {
                                notes = "Warnings suppressed";
                            }
                            else if (paramInvocation.WasSkipped)
                            {
                                notes = "Skipped during build";
                            }
                            else if (paramInvocation.ExecutionTimeMs == 0)
                            {
                                notes = "From cache";
                            }

                            sb.AppendLine($"| {status} | {$"  â”œâ”€ **({parameters})**"} | `{paramInvocation.ExecutionTimeMs:N0}ms` | {paramInvocation.Cache} | {count} | {paramInvocation.MemoryFootprintBytesFormatted()} | {notes} |");
                        }
                    }
                    else
                    {
                        var status = method.WasSkipped
                                        ? "â­ï¸ SKIP"
                                        : method.ThresholdExceeded
                                            ? "âš ï¸ SLOW"
                                            : "âœ… OK";

                        var notes = string.Empty;
                        if (method.ThresholdExceeded && !method.WasSuppressed)
                        {
                            notes = $"Slow (+{method.ExecutionTimeMs - method.ThresholdMs}ms over {method.ThresholdMs}ms limit)";
                        }
                        else if (method.WasSuppressed)
                        {
                            notes = "Warnings suppressed";
                        }
                        else if (method.WasSkipped)
                        {
                            notes = "Skipped during build";
                        }
                        else if (method.ExecutionTimeMs == 0)
                        {
                            notes = "From cache";
                        }

                        sb.AppendLine($"| {status} | **{method.MethodName}()** | `{method.ExecutionTimeMs:N0}ms` | {method.Cache} | 1 | {method.MemoryFootprintBytesFormatted()} | {notes} |");
                    }
                }
            }

            // Errors section
            var errorMethods = _items.Where(m => !string.IsNullOrEmpty(m.ErrorMessage)).ToList();
            if (errorMethods.Count != 0)
            {
                sb.AppendLine("## âŒ Errors");
                sb.AppendLine();
                foreach (var method in errorMethods)
                {
                    sb.AppendLine($"- **{method.ClassName}.{method.MethodName}()**: {method.ErrorMessage}");
                }
                sb.AppendLine();
            }
        }
        else
        {
            sb.AppendLine("*No methods processed.*");
        }

        File.WriteAllText(FileName, sb.ToString());
    }

    public class Item
    {
        public string MethodName { get; set; } = string.Empty;
        public CacheStrategy Cache { get; set; }
        public string ClassName { get; set; } = string.Empty;
        public string Namespace { get; set; } = string.Empty;
        public long ExecutionTimeMs { get; set; }
        public int ThresholdMs { get; set; }
        public bool ThresholdExceeded { get; set; }
        public bool WasSuppressed { get; set; }
        public bool WasSkipped { get; set; }
        public string? ErrorMessage { get; set; }
        public long MemoryFootprintBytes { get; set; }
        public string Parameters { get; set; } = default!;

        public string MemoryFootprintBytesFormatted()
        {
            var Suffix = new[] { "B", "KB", "MB", "GB", "TB" };
            var i = 0;
            double dblSByte = MemoryFootprintBytes;

            while (Math.Round(dblSByte / 1024) >= 1 && i < Suffix.Length - 1)
            {
                dblSByte /= 1024;
                i++;
            }

            return $"{dblSByte:N0} {Suffix[i]}";
        }
    }
}
