using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;

namespace Corsinvest.Fx.Functional;

[Generator]
public class UnionGenerator : IIncrementalGenerator
{
    // Diagnostic descriptors
    private static readonly DiagnosticDescriptor UnionGenerationFailedDescriptor = new(
        id: "UNION001",
        title: "Union generation failed",
        messageFormat: "Failed to generate union for '{0}': {1}",
        category: "Generator",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor UnionMustBePartialDescriptor = new(
        id: "UNION002",
        title: "Union type must be partial",
        messageFormat: "Type '{0}' with [Union] attribute must be declared as 'partial'",
        category: "Design",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor VariantMustBePartialDescriptor = new(
        id: "UNION003",
        title: "Union variant must be partial",
        messageFormat: "Variant '{0}' in union '{1}' must be declared as 'partial record'",
        category: "Design",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Debug support
#if DEBUG
        if (!System.Diagnostics.Debugger.IsAttached)
        {
            // System.Diagnostics.Debugger.Launch();
        }
#endif

        // Test basic generation
        context.RegisterPostInitializationOutput(static ctx =>
        {
            ctx.AddSource("UnionGeneratorTest.g.cs", @"// <auto-generated/>
// Union Generator is active and working
namespace Corsinvest.Fx.Functional
{
    public static class UnionGeneratorTest
    {
        public const bool IsActive = true;
    }
}");
        });

        // Find types with [Union] attribute
        var unionDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsUnionCandidate(node),
                transform: static (ctx, _) => GetUnionGenerationContext(ctx))
            .Where(static ctx => ctx is not null);

        context.RegisterSourceOutput(
            unionDeclarations,
            static (spc, genContext) => ProcessUnionGeneration(spc, genContext!));
    }

    private static bool IsUnionCandidate(SyntaxNode node)
        => node is RecordDeclarationSyntax record
            && record.AttributeLists.Count > 0;

    private static UnionGenerationContext? GetUnionGenerationContext(GeneratorSyntaxContext context)
    {
        var record = (RecordDeclarationSyntax)context.Node;
        var diagnostics = new List<Diagnostic>();

        var unionAttr = record.AttributeLists
                              .SelectMany(al => al.Attributes)
                              .FirstOrDefault(a => a.Name.ToString().Contains("Union"));
        if (unionAttr == null)
        {
            return null;
        }

        // Check if main record is partial
        var isPartial = record.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
        if (!isPartial)
        {
            var diagnostic = Diagnostic.Create(
                UnionMustBePartialDescriptor,
                record.Identifier.GetLocation(),
                record.Identifier.Text);
            diagnostics.Add(diagnostic);

            // Return context with diagnostics only, no code generation
            return new UnionGenerationContext(null, diagnostics);
        }

        // Get all nested records (variants)
        var allVariants = record.Members.OfType<RecordDeclarationSyntax>().ToList();
        var variants = new List<VariantInfo>();

        foreach (var variant in allVariants)
        {
            var isVariantPartial = variant.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));

            if (!isVariantPartial)
            {
                // Report diagnostic for non-partial variant
                var diagnostic = Diagnostic.Create(
                    VariantMustBePartialDescriptor,
                    variant.Identifier.GetLocation(),
                    variant.Identifier.Text,
                    record.Identifier.Text);
                diagnostics.Add(diagnostic);
            }
            else
            {
                // Add to variants list only if partial
                variants.Add(new VariantInfo(
                    Name: variant.Identifier.Text,
                    Parameters: variant.ParameterList?.Parameters
                        .Select(p => new ParamInfo(p.Type!.ToString(), p.Identifier.Text))
                        .ToList() ?? []
                ));
            }
        }

        var unionInfo = new UnionInfo(
            Namespace: GetNamespace(record),
            TypeName: record.Identifier.Text,
            TypeParameters: GetTypeParameters(record),
            Variants: variants,
            Location: record.Identifier.GetLocation()
        );

        return new UnionGenerationContext(unionInfo, diagnostics);
    }

    private static string GetNamespace(SyntaxNode node)
    {
        var parent = node.Parent;
        while (parent != null)
        {
            if (parent is NamespaceDeclarationSyntax ns) { return ns.Name.ToString(); }
            if (parent is FileScopedNamespaceDeclarationSyntax fsns) { return fsns.Name.ToString(); }

            parent = parent.Parent;
        }
        return string.Empty;
    }

    private static string GetTypeParameters(RecordDeclarationSyntax record)
        => record.TypeParameterList is null
            ? string.Empty
            : record.TypeParameterList.ToString();

    private static void ProcessUnionGeneration(SourceProductionContext context, UnionGenerationContext genContext)
    {
        // Report all diagnostics first
        foreach (var diagnostic in genContext.Diagnostics)
        {
            context.ReportDiagnostic(diagnostic);
        }

        // Only generate code if UnionInfo is available (no critical errors)
        if (genContext.UnionInfo is not null)
        {
            GenerateUnion(context, genContext.UnionInfo);
        }
    }

    private static void GenerateUnion(SourceProductionContext context, UnionInfo unionInfo)
    {
        try
        {
            context.AddSource($"{unionInfo.TypeName}.g.cs", GenerateUnionSource(unionInfo));
        }
        catch (Exception ex)
        {
            // Report diagnostic for generation errors
            context.ReportDiagnostic(Diagnostic.Create(
                UnionGenerationFailedDescriptor,
                unionInfo.Location ?? Location.None,
                unionInfo.TypeName,
                ex.Message));
        }
    }

    private static string GenerateUnionSource(UnionInfo unionInfo)
    {
        var sb = new StringBuilder();

        // Header
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(unionInfo.Namespace))
        {
            sb.AppendLine($"namespace {unionInfo.Namespace};");
            sb.AppendLine();
        }

        // Type declaration
        sb.AppendLine($"public partial record {unionInfo.TypeName}{unionInfo.TypeParameters}");
        sb.AppendLine("{");

        // Private constructor (sealed hierarchy)
        sb.AppendLine($"    private {unionInfo.TypeName}() {{ }}");
        sb.AppendLine();

        // Sealed variants
        foreach (var variant in unionInfo.Variants)
        {
            GenerateVariant(sb, unionInfo, variant);
        }

        // Type checking properties
        foreach (var variant in unionInfo.Variants)
        {
            sb.AppendLine($"    public bool Is{variant.Name} => this is {variant.Name};");
        }
        sb.AppendLine();

        // Match methods
        GenerateMatchMethods(sb, unionInfo);

        // TryGet methods
        GenerateTryGetMethods(sb, unionInfo);

        sb.AppendLine("}");

        // Union extensions 
        GenerateUnionExtensions(sb, unionInfo);

        return sb.ToString();
    }

    private static void GenerateVariant(StringBuilder sb, UnionInfo unionInfo, VariantInfo variant)
    {
        // For records without parameters, generate a simple sealed record
        // For records with parameters, the parameters are already in the user declaration
        sb.AppendLine($"    public sealed partial record {variant.Name} : {unionInfo.TypeName}{unionInfo.TypeParameters};");
        sb.AppendLine();
    }

    private static void GenerateUnionExtensions(StringBuilder sb, UnionInfo unionInfo)
    {
        // Parametri generici della union
        var genericParamsList = !string.IsNullOrEmpty(unionInfo.TypeParameters)
            ? unionInfo.TypeParameters.Trim('<', '>').Split(',').Select(p => p.Trim()).ToList()
            : [];

        // Classe di estensione
        sb.AppendLine($"public static class {unionInfo.TypeName}UnionExtensions");
        sb.AppendLine("{");

        // 1️⃣ Async Match con TResult (Task<TResult>) -> Func<Task<TResult>>
        {
            var methodGenericParams = new List<string>(genericParamsList) { "TResult" };
            var methodGenericParamsString = $"<{string.Join(", ", methodGenericParams)}>";

            sb.AppendLine($"    public static async Task<TResult> MatchAsync{methodGenericParamsString}(");
            sb.AppendLine($"        this Task<{unionInfo.TypeName}{unionInfo.TypeParameters}> task,");

            for (int i = 0; i < unionInfo.Variants.Count; i++)
            {
                var variant = unionInfo.Variants[i];
                var comma = i < unionInfo.Variants.Count - 1 ? "," : string.Empty;
                sb.AppendLine($"        Func<{unionInfo.TypeName}{unionInfo.TypeParameters}.{variant.Name}, Task<TResult>> on{variant.Name}{comma}");
            }

            sb.AppendLine("    )");
            sb.AppendLine("    {");
            sb.AppendLine("        var result = await task;");
            sb.AppendLine("        return await result.MatchAsync(");
            for (int i = 0; i < unionInfo.Variants.Count; i++)
            {
                var variant = unionInfo.Variants[i];
                var comma = i < unionInfo.Variants.Count - 1 ? "," : string.Empty;
                sb.AppendLine($"            on{variant.Name}{comma}");
            }
            sb.AppendLine("        );");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        // 2️⃣ Async Match senza TResult (Task) -> Func<Task>
        {
            var methodGenericParamsString = genericParamsList.Count > 0 
                                                ? $"<{string.Join(", ", genericParamsList)}>" 
                                                : string.Empty;

            sb.AppendLine($"    public static async Task MatchAsync{methodGenericParamsString}(");
            sb.AppendLine($"        this Task<{unionInfo.TypeName}{unionInfo.TypeParameters}> task,");

            for (int i = 0; i < unionInfo.Variants.Count; i++)
            {
                var variant = unionInfo.Variants[i];
                var comma = i < unionInfo.Variants.Count - 1 
                                ? "," 
                                : string.Empty;

                sb.AppendLine($"        Func<{unionInfo.TypeName}{unionInfo.TypeParameters}.{variant.Name}, Task> on{variant.Name}{comma}");
            }

            sb.AppendLine("    )");
            sb.AppendLine("    {");
            sb.AppendLine("        var result = await task;");
            sb.AppendLine("        await result.MatchAsync(");
            for (int i = 0; i < unionInfo.Variants.Count; i++)
            {
                var variant = unionInfo.Variants[i];
                var comma = i < unionInfo.Variants.Count - 1 
                            ? "," 
                            : string.Empty;

                sb.AppendLine($"            on{variant.Name}{comma}");
            }
            sb.AppendLine("        );");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        // 3️⃣ Async Match con TResult (Task<TResult>) -> Func<TResult> (sincrona)
        {
            var methodGenericParams = new List<string>(genericParamsList) { "TResult" };
            var methodGenericParamsString = $"<{string.Join(", ", methodGenericParams)}>";

            sb.AppendLine($"    public static async Task<TResult> MatchAsync{methodGenericParamsString}(");
            sb.AppendLine($"        this Task<{unionInfo.TypeName}{unionInfo.TypeParameters}> task,");
            for (int i = 0; i < unionInfo.Variants.Count; i++)
            {
                var variant = unionInfo.Variants[i];
                var comma = i < unionInfo.Variants.Count - 1 
                                ? "," 
                                : string.Empty;

                sb.AppendLine($"        Func<{unionInfo.TypeName}{unionInfo.TypeParameters}.{variant.Name}, TResult> on{variant.Name}{comma}");
            }

            sb.AppendLine("    )");
            sb.AppendLine("    {");
            sb.AppendLine("        var result = await task;");
            sb.AppendLine("        return result.Match(");
            for (int i = 0; i < unionInfo.Variants.Count; i++)
            {
                var variant = unionInfo.Variants[i];
                var comma = i < unionInfo.Variants.Count - 1 
                                ? "," 
                                : string.Empty;

                sb.AppendLine($"            on{variant.Name}{comma}");
            }
            sb.AppendLine("        );");
            sb.AppendLine("    }");

        }

        sb.AppendLine("}");
    }

    private static void GenerateMatchMethods(StringBuilder sb, UnionInfo unionInfo)
    {
        // Sync Match with return value
        sb.AppendLine("    public TResult Match<TResult>(");
        for (int i = 0; i < unionInfo.Variants.Count; i++)
        {
            var variant = unionInfo.Variants[i];
            var comma = i < unionInfo.Variants.Count - 1 
                            ? "," 
                            : string.Empty;

            sb.AppendLine($"        Func<{variant.Name}, TResult> on{variant.Name}{comma}");
        }
        sb.AppendLine("    )");
        sb.AppendLine("    {");
        sb.AppendLine("        return this switch");
        sb.AppendLine("        {");
        foreach (var variant in unionInfo.Variants)
        {
            sb.AppendLine($"            {variant.Name} {variant.Name.ToLowerInvariant()} => on{variant.Name}({variant.Name.ToLowerInvariant()}),");
        }
        sb.AppendLine("            _ => throw new InvalidOperationException(\"Invalid union state\")");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Sync Match without return value
        sb.AppendLine("    public void Match(");
        for (int i = 0; i < unionInfo.Variants.Count; i++)
        {
            var variant = unionInfo.Variants[i];
            var comma = i < unionInfo.Variants.Count - 1 
                            ? "," 
                            : string.Empty;

            sb.AppendLine($"        Action<{variant.Name}> on{variant.Name}{comma}");
        }
        sb.AppendLine("    )");
        sb.AppendLine("    {");
        sb.AppendLine("        switch (this)");
        sb.AppendLine("        {");
        foreach (var variant in unionInfo.Variants)
        {
            sb.AppendLine($"            case {variant.Name} {variant.Name.ToLowerInvariant()}:");
            sb.AppendLine($"                on{variant.Name}({variant.Name.ToLowerInvariant()});");
            sb.AppendLine($"                break;");
        }
        sb.AppendLine("            default:");
        sb.AppendLine("                throw new InvalidOperationException(\"Invalid union state\");");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Async Match methods
        GenerateAsyncMatchMethods(sb, unionInfo);
    }

    private static void GenerateAsyncMatchMethods(StringBuilder sb, UnionInfo unionInfo)
    {
        // Async Match with return value
        sb.AppendLine("    public async Task<TResult> MatchAsync<TResult>(");
        for (int i = 0; i < unionInfo.Variants.Count; i++)
        {
            var variant = unionInfo.Variants[i];
            var comma = i < unionInfo.Variants.Count - 1 
                            ? "," 
                            : string.Empty;

            sb.AppendLine($"        Func<{variant.Name}, Task<TResult>> on{variant.Name}{comma}");
        }
        sb.AppendLine("    )");
        sb.AppendLine("    {");
        sb.AppendLine("        return this switch");
        sb.AppendLine("        {");
        foreach (var variant in unionInfo.Variants)
        {
            sb.AppendLine($"            {variant.Name} {variant.Name.ToLowerInvariant()} => await on{variant.Name}({variant.Name.ToLowerInvariant()}),");
        }
        sb.AppendLine("            _ => throw new InvalidOperationException(\"Invalid union state\")");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Async Match without return value
        sb.AppendLine("    public async Task MatchAsync(");
        for (int i = 0; i < unionInfo.Variants.Count; i++)
        {
            var variant = unionInfo.Variants[i];
            var comma = i < unionInfo.Variants.Count - 1 
                        ? "," 
                        : string.Empty;

            sb.AppendLine($"        Func<{variant.Name}, Task> on{variant.Name}{comma}");
        }
        sb.AppendLine("    )");
        sb.AppendLine("    {");
        sb.AppendLine("        switch (this)");
        sb.AppendLine("        {");
        foreach (var variant in unionInfo.Variants)
        {
            sb.AppendLine($"            case {variant.Name} {variant.Name.ToLowerInvariant()}:");
            sb.AppendLine($"                await on{variant.Name}({variant.Name.ToLowerInvariant()});");
            sb.AppendLine($"                break;");
        }
        sb.AppendLine("            default:");
        sb.AppendLine("                throw new InvalidOperationException(\"Invalid union state\");");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateTryGetMethods(StringBuilder sb, UnionInfo unionInfo)
    {
        foreach (var variant in unionInfo.Variants)
        {
            sb.AppendLine($"    public bool TryGet{variant.Name}(out {variant.Name} {variant.Name.ToLowerInvariant()})");
            sb.AppendLine("    {");
            sb.AppendLine($"        if (this is {variant.Name} {variant.Name.ToLowerInvariant()}Value)");
            sb.AppendLine("        {");
            sb.AppendLine($"            {variant.Name.ToLowerInvariant()} = {variant.Name.ToLowerInvariant()}Value;");
            sb.AppendLine("            return true;");
            sb.AppendLine("        }");
            sb.AppendLine($"        {variant.Name.ToLowerInvariant()} = default!;");
            sb.AppendLine("        return false;");
            sb.AppendLine("    }");
            sb.AppendLine();
        }
    }

}

// Data structures for union metadata
internal record UnionInfo(
    string Namespace,
    string TypeName,
    string TypeParameters,
    List<VariantInfo> Variants,
    Location? Location
);

internal record VariantInfo(string Name, List<ParamInfo> Parameters);
internal record ParamInfo(string Type, string Name);

internal record UnionGenerationContext(
    UnionInfo? UnionInfo,
    List<Diagnostic> Diagnostics
);